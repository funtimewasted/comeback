<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Question Bank</title>
    <style>
        /* --- START OF styles.css --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8fafc; /* Light background for body */
            color: #1e293b; /* Default text color */
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #ffffff; /* White background for main container */
            padding: 20px 30px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            border: 1px solid #e2e8f0;
        }

        .header {
            text-align: left;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e2e8f0;
        }

        .header h1 {
            font-size: 24px;
            margin: 0;
            color: #0f172a; /* Darker heading */
        }

        .nav-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .subjects {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 10px;
        }

        .secondary-nav {
            display: flex;
            gap: 10px;
            padding-left: 0; /* No indent needed now */
            align-items: center;
        }

        .nav-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            transition: all 0.2s ease;
            color: #334155;
        }

        .nav-btn:hover {
            background-color: #f8f9fa;
            border-color: #cbd5e1;
        }

        .nav-btn.active {
            background-color: #0f172a;
            color: white;
            border-color: #0f172a; /* Match border */
        }
        .nav-btn.active span { /* Adjust icon color on active */
             filter: brightness(0) invert(1);
        }


        .semester-toggle {
            display: flex;
            gap: 5px;
            background-color: #f1f5f9;
            padding: 4px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }

        .semester-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            background: none;
            color: #334155; /* Default color */
            transition: all 0.2s ease;
        }

        .semester-btn.active {
            background-color: #ffffff;
            color: #0f172a; /* Active color */
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        /* --- Topic List Styles (#content) --- */
        #content {
            /* Styles for when the topic list is visible */
        }

        .unit-container {
            background-color: #ffffff;
            border-radius: 12px;
            padding: 25px; /* Slightly more padding */
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            border: 1px solid #e0e0e0;
            margin-bottom: 20px;
        }
        #content .unit-container:last-child {
             margin-bottom: 0;
        }

        .unit-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #1e293b; /* Darker title color */
        }

        .section {
            margin-bottom: 25px;
        }
        .section:last-child {
            margin-bottom: 0;
        }

        .section-title {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 15px;
            color: #4a5568;
        }

        .section-content {
            padding: 15px;
            background-color: #ffffff;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            margin-bottom: 10px;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            font-size: 15px;
            color: #334155;
        }
        .section-content:last-child {
            margin-bottom: 0;
        }

        .section-content:hover {
            background-color: #f1f5f9; /* Lighter blue on hover */
            border-color: #94a3b8;
        }

        .semester-content {
            display: none;
        }
        .semester-content.active {
            display: block;
        }

        /* --- Quiz View Styles (#quiz-view) --- */
        #quiz-view {
             padding: 20px 0; /* Add some padding when visible */
        }

        #quiz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e2e8f0;
        }

        #quiz-title {
            font-size: 20px;
            font-weight: 600;
            color: #1e293b;
        }

        #quiz-container { /* Container specifically for question content */
            margin-bottom: 20px;
        }

         /* Style for the specific question type wrapper inside quiz */
        .question-type-wrapper {
            padding: 25px; /* More padding */
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #ffffff; /* White background for question area */
            margin-bottom: 20px; /* Space before feedback/buttons */
             box-shadow: 0 1px 2px rgba(0,0,0,0.04);
        }

        .question-progress {
            font-size: 14px;
            color: #64748b;
            margin-bottom: 15px;
            text-align: right;
        }

        .question-text {
            font-size: 18px;
            margin-bottom: 25px;
            line-height: 1.6;
            color: #1e293b;
        }
        .question-text strong {
            font-weight: 600;
            margin-right: 5px;
        }

        /* --- Multiple Choice Specific --- */
        .options-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 0; /* Remove margin if wrapper has padding */
        }
        .option-label {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: #fff;
        }
        .option-label:hover {
            background-color: #f1f5f9;
            border-color: #cbd5e1;
        }
        .option-label input:checked + .option-text { font-weight: 500; }
        .option-label input:checked { accent-color: #2563eb; }
        .option-input { margin-right: 15px; flex-shrink: 0; }
        .option-text { flex-grow: 1; font-size: 16px; color: #334155; }

        /* --- Matching Specific --- */
        .matching-instructions { font-size: 15px; color: #475569; margin-bottom: 20px; }
        .matching-container { display: flex; justify-content: space-between; gap: 20px; margin-bottom: 0; }
        .matching-column { flex: 1; display: flex; flex-direction: column; gap: 10px; }
        .matching-column h4 { margin: 0 0 10px 0; font-size: 15px; font-weight: 600; color: #4a5568; border-bottom: 1px solid #e2e8f0; padding-bottom: 5px; }
        .matching-item { padding: 10px 15px; border: 1px solid #cbd5e1; background-color: #fff; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; font-size: 15px; }
        .matching-item:hover { background-color: #f1f5f9; border-color: #94a3b8; }
        .matching-item.selected { background-color: #dbeafe; border-color: #60a5fa; font-weight: 500; }
        .matching-item.matched { background-color: #e5e7eb; border-color: #9ca3af; cursor: not-allowed; opacity: 0.8; }
        .review-matched-pair-correct { background-color: #dcfce7 !important; border-color: #16a34a !important; }
        .review-matched-pair-incorrect { background-color: #fee2e2 !important; border-color: #ef4444 !important; }

        /* --- Ordering Specific --- */
        .ordering-instructions { font-size: 15px; color: #475569; margin-bottom: 20px; }
        .ordering-container { display: flex; flex-direction: column; gap: 15px; margin-bottom: 0; }
        .ordering-item { display: flex; align-items: center; padding: 10px 15px; border: 1px solid #e2e8f0; background-color: #fff; border-radius: 6px; }
        .ordering-select { margin-right: 15px; padding: 5px 8px; border-radius: 4px; border: 1px solid #cbd5e1; font-size: 14px; min-width: 60px; }
        .ordering-text { flex-grow: 1; font-size: 16px; }
        .review-order-number { font-weight: 600; min-width: 25px; text-align: right; margin-right: 10px; }
        .review-order-correct { color: #059669; }
        .review-order-incorrect { color: #dc2626; text-decoration: line-through; margin-right: 5px;}

        /* --- Feedback & Buttons (Shared by Quiz, Results, Review) --- */
        .feedback-container {
            padding: 15px;
            margin-top: 20px; /* Space above feedback */
            border-radius: 6px;
            background-color: #f1f5f9; /* Slightly different background for feedback */
            border: 1px solid #e2e8f0;
        }
         .feedback-container.hidden { display: none; }

        .correct-feedback { color: #059669; font-weight: 600; font-size: 16px; }
        .incorrect-feedback { color: #dc2626; font-weight: 600; font-size: 16px; }
        .incorrect-feedback span { display: block; font-weight: 500; margin-top: 8px; font-size: 15px; color: #475569; line-height: 1.5; }
        .partial-feedback { color: #ca8a04; font-weight: 600; font-size: 16px; }

        /* Highlighting applied after submission */
        .correct-option { background-color: #dcfce7 !important; border-color: #16a34a !important; }
        .correct-option .option-text { color: #065f46 !important; }
        .incorrect-option { background-color: #fee2e2 !important; border-color: #ef4444 !important; }
        .incorrect-option .option-text { color: #b91c1c !important; }

        /* Button container */
        .quiz-buttons, .results-actions, .review-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 25px;
            border-top: 1px solid #e2e8f0;
            padding-top: 20px;
        }
         /* Add specific class if review needs different button layout */
         .review-actions {
             justify-content: space-between; /* e.g., Back button left, Close right */
         }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            transition: all 0.2s ease;
            line-height: 1.5;
        }

        /* Specific Button Styles */
        .submit-btn { background-color: #2563eb; color: white; }
        .submit-btn:hover:not(:disabled) { background-color: #1d4ed8; }
        .submit-btn:disabled { background-color: #94a3b8; cursor: not-allowed; }
        .next-btn { background-color: #059669; color: white; }
        .next-btn:hover { background-color: #047857; }
        .review-btn { background-color: #16a34a; color: white; } /* Results Review */
        .review-btn:hover { background-color: #15803d; }
        .close-btn, .back-to-topics-btn { background-color: #64748b; color: white; } /* Results/Error Close/Back */
        .close-btn:hover, .back-to-topics-btn:hover { background-color: #475569; }
        .back-btn { background-color: #64748b; color: white; } /* Review Back to Results */
        .back-btn:hover { background-color: #475569; }

        .hidden { display: none !important; }

        /* --- Error Message Styles (for showError) --- */
        .error-display { /* Wrapper for error message within quiz view */
             padding: 30px;
             text-align: center;
             background-color: #fef2f2;
             border: 1px solid #fecaca;
             border-radius: 8px;
        }
        .error-message { color: #b91c1c; font-weight: 500; margin-bottom: 20px; }
        /* .add-question-prompt { color: #475569; } */
        /* .add-question-prompt p { margin-bottom: 10px; } */


        /* --- Results Styles (within #quiz-view) --- */
        .results-container { padding: 10px 0; text-align: center; } /* Adjusted padding */
        .results-header { font-size: 24px; margin-bottom: 25px; color: #1e293b; }
        .results-score { margin: 30px 0 35px 0; }
        .score-circle { width: 140px; height: 140px; border-radius: 50%; background-color: #f1f5f9; display: flex; flex-direction: column; align-items: center; justify-content: center; margin: 0 auto; border: 6px solid #2563eb; box-shadow: 0 0 15px rgba(37, 99, 235, 0.2); }
        .score-number { font-size: 40px; font-weight: bold; color: #1e293b; line-height: 1; }
        .score-percent-sign { font-size: 18px; font-weight: 500; color: #475569; margin-top: 2px; }
        .results-details { max-width: 450px; margin: 0 auto 35px auto; text-align: left; background-color: #f8fafc; padding: 25px; border-radius: 8px; border: 1px solid #e2e8f0; }
        .results-details p { margin: 10px 0; font-size: 15px; color: #334155; }
        .results-details p strong { color: #1e293b; min-width: 120px; display: inline-block; }

        /* --- Review Answers Styles (within #quiz-view) --- */
        .review-container { padding: 10px 0; } /* Adjusted padding */
        /* .back-btn styling is above */
        .question-review { padding: 20px; margin-bottom: 20px; border-radius: 8px; border: 1px solid #e2e8f0; border-left-width: 5px; background-color: #fff; }
        .question-review.correct { border-left-color: #16a34a; }
        .question-review.incorrect { border-left-color: #ef4444; }
        .question-review.partial { border-left-color: #f59e0b; }
        .review-question-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #e2e8f0; }
        .review-question-number { font-weight: 600; color: #1e293b; font-size: 16px; }
        .review-status { font-weight: 600; font-size: 14px; padding: 3px 8px; border-radius: 4px; text-align: center; }
        .question-review.correct .review-status { color: #065f46; background-color: #dcfce7; }
        .question-review.incorrect .review-status { color: #991b1b; background-color: #fee2e2; }
        .question-review.partial .review-status { color: #854d0e; background-color: #fef9c3; }
        .review-question-text { margin-bottom: 15px; font-size: 16px; color: #334155; }

        /* Review specific content styles */
        .review-mc-answer, .review-matching-answer, .review-ordering-answer { background-color: #f8fafc; padding: 15px; border-radius: 6px; border: 1px solid #e2e8f0; margin-top: 15px; }
        .review-mc-answer p, .review-matching-answer p, .review-ordering-answer p { margin: 8px 0; font-size: 15px; color: #475569; }
        .review-mc-answer p strong, .review-matching-answer p strong, .review-ordering-answer p strong { color: #1e293b; margin-right: 5px; display: inline-block; min-width: 110px; }
        .review-mc-answer .correct-answer-text, .review-matching-answer .correct-answer-text, .review-ordering-answer .correct-answer-text { color: #059669; font-weight: 500; }
        .review-mc-answer .user-answer-text.incorrect { color: #dc2626; text-decoration: line-through; }
        .review-mc-answer .user-answer-text.correct { color: #059669; font-weight: 500; }

        /* Review Matching Specific */
        .review-matching-grid { display: flex; gap: 15px; margin-top: 10px; }
        .review-matching-column { flex: 1; }
        .review-matching-column div { padding: 5px 8px; margin-bottom: 5px; border-radius: 4px; border: 1px solid #e2e8f0; background-color: #fff; }

        /* Review Ordering Specific */
        .review-ordering-list { margin-top: 10px; }
        .review-ordering-list-item { display: flex; align-items: center; margin-bottom: 5px; padding: 5px 8px; border-radius: 4px; border: 1px solid #e2e8f0; background-color: #fff; }

        /* --- END OF styles.css --- */
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Interactive Question Bank</h1>
        </div>

        <!-- Navigation remains the same -->
        <div class="nav-section">
            <div class="subjects">
                <button class="nav-btn" data-subject="اللغة العربية">
                    <span>📚</span> اللغة العربية
                </button>
                <button class="nav-btn active" data-subject="english">
                    <span>🌎</span> English
                </button>
                <button class="nav-btn" data-subject="التاريخ">
                    <span>📜</span> التاريخ
                </button>
                <button class="nav-btn" data-subject="دين">
                    <span>📖</span> دين
                </button>
            </div>
            <div class="secondary-nav">
                <div class="semester-toggle">
                    <button class="semester-btn active" data-semester="first">First Semester</button>
                    <button class="semester-btn" data-semester="second">Second Semester</button>
                </div>
            </div>
        </div>

        <!-- Content Area for Topic Lists -->
        <div id="content">
            <!-- Topic lists will be loaded dynamically here -->
        </div>

        <!-- Quiz View Area (Initially Hidden) -->
        <div id="quiz-view" class="hidden">
            <div id="quiz-header">
                <h2 id="quiz-title">Quiz Title</h2>
                <!-- Maybe add a "Back to Topics" button here later -->
                 <button class="btn back-to-topics-btn" onclick="showTopicList()">← Back to Topics</button>
            </div>
            <div id="quiz-container">
                 <!-- Quiz Question/Results/Review content loads here -->
            </div>
             <div id="feedback-container" class="feedback-container hidden">
                 <!-- Feedback messages load here -->
             </div>
             <div id="quiz-buttons-container" class="quiz-buttons">
                 <!-- Submit/Next buttons load here -->
            </div>
        </div>

    </div> <!-- End of .container -->

    <script>
        // --- START OF topics.js ---

        // Topics data structure - CORRECTED DATA
        const topicsData = {
            "english": {
                "first": {
                    "title": "First Semester",
                    "units": [
                        {
                            "title": "Unit 1",
                            "lessons": [
                                {
                                    "title": "Vocabulary & Grammar Basics",
                                    "questions": [
                                        {
                                            "type": "multiple_choice", // Explicit type
                                            "question": "What literary device is used in the phrase 'the curtain of night fell'?",
                                            "options": ["Simile", "Metaphor", "Alliteration", "Hyperbole"],
                                            "answer": "Metaphor"
                                        },
                                        {
                                            "type": "multiple_choice",
                                            "question": "The word 'ambiguous' most closely means:",
                                            "options": ["Clear", "Uncertain", "Definite", "Determined"],
                                            "answer": "Uncertain"
                                        },
                                        {
                                            "type": "ordering", // Ordering Question Example (5 items)
                                            "question": "Order the following words alphabetically:",
                                            "items": ["Banana", "Apple", "Cherry", "Date", "Fig"], // 5 items
                                            "answer": ["Apple", "Banana", "Cherry", "Date", "Fig"] // 5 items in correct order
                                        },
                                        {
                                            "type": "matching", // Matching Question Example (5 pairs)
                                            "question": "Match the country with its capital city:",
                                            "prompts": ["France", "Japan", "Egypt", "Brazil", "Canada"], // 5 prompts
                                            "matches": ["Cairo", "Tokyo", "Paris", "Brasília", "Ottawa"], // 5 matches (will be shuffled)
                                            "answer": { // Correct pairings: { promptIndex: originalMatchIndex }
                                                "0": 2, // France -> Paris
                                                "1": 1, // Japan -> Tokyo
                                                "2": 0, // Egypt -> Cairo
                                                "3": 3, // Brazil -> Brasília
                                                "4": 4  // Canada -> Ottawa
                                            }
                                        },
                                        {
                                            "type": "ordering", // Ordering Question Example (3 items)
                                            "question": "Order the steps to make tea:",
                                            "items": ["Add tea bag", "Boil water", "Pour water"],
                                            "answer": ["Boil water", "Add tea bag", "Pour water"]
                                        }
                                    ]
                                },
                                {
                                    "title": "Past&Present Tenses&Question Tags",
                                    "questions": [
                                        {
                                            "type": "multiple_choice",
                                            "question": "Choose the correct present tense: 'She _____ to school every day.'",
                                            "options": ["go", "goes", "going", "went"],
                                            "answer": "goes"
                                        },
                                        {
                                            "type": "multiple_choice",
                                            "question": "Which is the correct question tag? 'You're coming to the party, _____?'",
                                            "options": ["aren't you", "don't you", "isn't you", "won't you"],
                                            "answer": "aren't you"
                                        }
                                    ]
                                }
                            ]
                        },
                        // Other units remain structurally, questions empty for brevity
                         { "title": "Unit 2", "lessons": [ { "title": "Reading and Vocabulary", "questions": [] }, { "title": "Future Forms", "questions": [] } ] },
                         { "title": "Unit 3", "lessons": [ { "title": "Reading and Vocabulary", "questions": [] }, { "title": "Habits&Clauses", "questions": [] } ] },
                         { "title": "Unit 4", "lessons": [ { "title": "Reading and Vocabulary", "questions": [] }, { "title": "Narration&Inversion", "questions": [] } ] }
                    ]
                },
                "second": { // Structure only
                    "title": "Second Semester",
                     "units": [
                        { "title": "Unit 1", "lessons": [ { "title": "Reading and Vocabulary", "questions": [] }, { "title": "Modal&Related&Articles", "questions": [] } ] },
                        { "title": "Unit 2", "lessons": [ { "title": "Reading and Vocabulary", "questions": [] }, { "title": "Reported Speach&Reporting Verbs", "questions": [] } ] },
                        { "title": "Unit 3", "lessons": [ { "title": "Reading and Vocabulary", "questions": [] }, { "title": "The Passive", "questions": [] } ] },
                        { "title": "Unit 4", "lessons": [ { "title": "Reading and Vocabulary", "questions": [] }, { "title": "Conditionals&Modals", "questions": [] } ] },
                        { "title": "Unit 5", "lessons": [ { "title": "Reading and Vocabulary", "questions": [] }, { "title": "Modals&Clauses", "questions": [] } ] }
                     ]
                }
            },
            // Other subjects remain structurally, questions empty
             "اللغة العربية": { "first": {"title": "الفصل الأول", "units": []}, "second": {"title": "الفصل الثاني", "units": []} },
             "التاريخ": { "first": {"title": "الفصل الأول", "units": []}, "second": {"title": "الفصل الثاني", "units": []} },
             "دين": { "first": {"title": "الفصل الأول", "units": []}, "second": {"title": "الفصل الثاني", "units": []} }
        };

        // Function to generate HTML for a semester's content
        function generateSemesterContent(subject, semester) {
             // Basic error checking for missing data
            if (!topicsData[subject] || !topicsData[subject][semester]) {
                console.error(`Data missing for subject: ${subject}, semester: ${semester}`);
                return `<div id="${subject}-${semester}" class="semester-content"><div class="unit-container"><p>Content not available.</p></div></div>`;
            }

            const semesterData = topicsData[subject][semester];
            let html = `<div id="${subject}-${semester}" class="semester-content">`; // Outer container

             // Check if units exist and is an array - if not, show message inside semester div
             if (!semesterData.units || !Array.isArray(semesterData.units) || semesterData.units.length === 0) {
                 html += `<div class="unit-container"><p>No units available for ${semesterData.title}.</p></div>`;
             } else {
                 semesterData.units.forEach(unit => {
                     if (unit && unit.title) {
                         // Start unit container
                         html += `<div class="unit-container">
                                    <div class="unit-title">${unit.title}</div>`;

                        if (unit.lessons && Array.isArray(unit.lessons) && unit.lessons.length > 0) {
                            unit.lessons.forEach(lesson => {
                                if (lesson && lesson.title) {
                                    html += `<div class="section">
                                                <div class="section-title">${lesson.title}</div>
                                                <div class="section-content" data-subject="${subject}" data-unit="${unit.title}" data-lesson="${lesson.title}">Start Quiz</div>
                                             </div>`;
                                } else {
                                     console.warn(`Invalid lesson structure in unit: ${unit.title}`, lesson);
                                }
                            });
                        } else {
                            // If a unit has no lessons, show a message within that unit's container
                            html += `<p style="margin-left: 15px; color: #64748b;">No lessons available in this unit yet.</p>`;
                            // console.warn(`No lessons array found for unit: ${unit.title}`);
                        }

                        html += `</div> <!-- .unit-container -->`; // End unit container
                    } else {
                         console.warn(`Invalid unit structure in subject: ${subject}, semester: ${semester}`, unit);
                    }
                });
             }
             html += `</div> <!-- .semester-content -->`; // End outer container
            return html;
        }


        // Generate content for all subjects and semesters
        function generateAllContent() {
            let contentHTML = '';
            const contentDiv = document.getElementById('content');
            if (!contentDiv) {
                console.error("Content container element not found!");
                return;
            }
            for (const subject in topicsData) {
                if (topicsData.hasOwnProperty(subject)) {
                    for (const semester in topicsData[subject]) {
                         if (topicsData[subject].hasOwnProperty(semester)) {
                            contentHTML += generateSemesterContent(subject, semester);
                         }
                    }
                }
            }
            contentDiv.innerHTML = contentHTML;
        }

        // Initialize content when the page loads
        document.addEventListener('DOMContentLoaded', generateAllContent);

        // --- END OF topics.js ---
    </script>

    <script>
        // --- START OF questions.js ---

        // --- Global State ---
        let quizState = {
            currentQuestionIndex: 0,
            correctAnswers: 0,
            totalQuestions: 0,
            startTime: null,
            endTime: null,
            selectedAnswers: [],
            questions: [],
            subject: '',
            unit: '',
            lesson: '',
            matchingState: { selectedPromptElement: null, userPairs: {} }
        };

        // --- DOM Element References ---
        // We get these once the DOM is ready
        let contentElement = null;
        let quizViewElement = null;
        let quizTitleElement = null;
        let quizContainerElement = null;
        let feedbackContainerElement = null;
        let quizButtonsContainerElement = null;


        // --- Utility Functions ---
        function shuffleArray(array) { /* Fisher-Yates Shuffle - remains same */ }


        // --- DOM Ready Listener ---
        document.addEventListener('DOMContentLoaded', () => {
            // Assign element references
            contentElement = document.getElementById('content');
            quizViewElement = document.getElementById('quiz-view');
            quizTitleElement = document.getElementById('quiz-title');
            quizContainerElement = document.getElementById('quiz-container');
            feedbackContainerElement = document.getElementById('feedback-container');
            quizButtonsContainerElement = document.getElementById('quiz-buttons-container');


            // Subject button listeners
            document.querySelectorAll('.nav-btn[data-subject]').forEach(button => {
                button.addEventListener('click', function() {
                     if (quizViewElement && !quizViewElement.classList.contains('hidden')) {
                         // If in quiz view, confirm before switching subject
                         if (!confirm("Are you sure you want to leave the current quiz? Progress will be lost.")) {
                             return; // Cancel subject change
                         }
                         showTopicList(); // Exit quiz view first
                     }
                    document.querySelectorAll('.nav-btn[data-subject]').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    updateContent(); // Update topic list view
                });
            });

            // Semester button listeners
            document.querySelectorAll('.semester-btn').forEach(button => {
                button.addEventListener('click', function() {
                    if (quizViewElement && !quizViewElement.classList.contains('hidden')) {
                        if (!confirm("Are you sure you want to leave the current quiz? Progress will be lost.")) {
                            return; // Cancel semester change
                        }
                         showTopicList(); // Exit quiz view first
                    }
                    document.querySelectorAll('.semester-btn').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    updateContent(); // Update topic list view
                });
            });

            // Initial content load (topics)
            updateContent();
        });


        // --- View Management ---

        function showTopicList() {
            if (contentElement && quizViewElement) {
                contentElement.classList.remove('hidden');
                quizViewElement.classList.add('hidden');
                // Reset quiz state when returning to list
                 quizState = {
                    currentQuestionIndex: 0, correctAnswers: 0, totalQuestions: 0,
                    startTime: null, endTime: null, selectedAnswers: [], questions: [],
                    subject: '', unit: '', lesson: '',
                    matchingState: { selectedPromptElement: null, userPairs: {} }
                };
                console.log("Returned to topic list, quiz state reset.");
            }
        }

        function showQuizView() {
             if (contentElement && quizViewElement) {
                 contentElement.classList.add('hidden');
                 quizViewElement.classList.remove('hidden');
                 // Scroll to top of quiz view
                 quizViewElement.scrollIntoView({ behavior: 'smooth' });
             }
        }


        // --- Core Functions ---

        // Update main topic list view
        function updateContent() {
            const activeSubjectBtn = document.querySelector('.nav-btn[data-subject].active');
            const activeSemesterBtn = document.querySelector('.semester-btn.active');
            if (!activeSubjectBtn || !activeSemesterBtn || !contentElement) return;

            const activeSubject = activeSubjectBtn.dataset.subject;
            const activeSemester = activeSemesterBtn.dataset.semester;

            // Hide all semester content divs within #content
            contentElement.querySelectorAll('.semester-content').forEach(content => {
                content.classList.remove('active');
            });

            const contentId = `${activeSubject}-${activeSemester}`;
            const semesterContentElement = contentElement.querySelector(`#${contentId}`); // Look inside #content

            if (semesterContentElement) {
                semesterContentElement.classList.add('active');
                // Re-attach listeners using clone/replace to section-content within the active semester div
                semesterContentElement.querySelectorAll('.section-content').forEach(section => {
                    const newSection = section.cloneNode(true);
                    section.parentNode.replaceChild(newSection, section);
                    newSection.addEventListener('click', function() {
                        handleSectionClick(this.dataset.subject, this.dataset.unit, this.dataset.lesson);
                    });
                });
            } else {
                 console.warn(`Semester content element with ID "${contentId}" not found within #content.`);
                 // Display error within the #content area if needed
                 // contentElement.innerHTML = `<p>Error loading content.</p>`;
            }
        }


        // Handle clicking a lesson -> Start Quiz
        function handleSectionClick(subject, unit, lesson) {
             if (!subject || !unit || !lesson) {
                 console.error("Missing data attributes on clicked section.");
                 // Display error inline maybe? Or alert.
                 alert("Error identifying the selected topic.");
                 return;
             }
            console.log(`Starting quiz for: Subject=${subject}, Unit=${unit}, Lesson=${lesson}`);
            try {
                const questions = getQuestions(subject, unit, lesson);
                if (questions && questions.length > 0) {
                    startQuiz(subject, unit, lesson, questions);
                } else {
                    console.log(`No questions found for ${subject} - ${unit} - ${lesson}`);
                    showError(subject, unit, lesson); // Show error within quiz view
                }
            } catch (error) {
                console.error("Error handling section click:", error);
                showError(subject, unit, lesson, "An error occurred while loading questions."); // Show error within quiz view
            }
        }

        // Start a new quiz - Set up state and switch view
        function startQuiz(subject, unit, lesson, questions) {
            quizState = {
                currentQuestionIndex: 0,
                correctAnswers: 0,
                totalQuestions: questions.length,
                startTime: new Date(),
                endTime: null,
                selectedAnswers: new Array(questions.length).fill(null),
                questions: questions,
                subject: subject,
                unit: unit,
                lesson: lesson,
                matchingState: { selectedPromptElement: null, userPairs: {} }
            };

            if (quizTitleElement) {
                quizTitleElement.textContent = `${lesson}`; // Set quiz title
            }
            showQuizView(); // Switch to the quiz interface
            displayQuestion(); // Display the first question
        }


        // Display the current question based on its type
        function displayQuestion() {
            if (!quizContainerElement || !feedbackContainerElement || !quizButtonsContainerElement) {
                console.error("Quiz view elements not found!"); return;
            }

            const currentQuestion = quizState.questions[quizState.currentQuestionIndex];
            if (!currentQuestion) {
                console.error("Error: Invalid question index.");
                displayResults(); return;
            }

            // Clear previous content
            quizContainerElement.innerHTML = '';
            feedbackContainerElement.innerHTML = '';
            feedbackContainerElement.classList.add('hidden'); // Hide feedback initially
            quizButtonsContainerElement.innerHTML = '';

            // --- Render Question ---
            const questionWrapper = document.createElement('div'); // Wrapper for all question parts
            questionWrapper.className = 'question-display-wrapper'; // Optional class

             // Progress
             const progressText = document.createElement('div');
             progressText.className = 'question-progress';
             progressText.textContent = `Question ${quizState.currentQuestionIndex + 1} of ${quizState.totalQuestions}`;
             questionWrapper.appendChild(progressText);

             // Question Text
             const questionText = document.createElement('p');
             questionText.className = 'question-text';
             questionText.innerHTML = `<strong>Q:</strong> ${currentQuestion.question || 'Missing question text'}`;
             questionWrapper.appendChild(questionText);


            // Type-specific rendering container
            const typeWrapper = document.createElement('div');
            typeWrapper.className = 'question-type-wrapper';
            try {
                 switch (currentQuestion.type) {
                    case "matching":
                        renderMatching(currentQuestion, typeWrapper);
                        break;
                    case "ordering":
                        renderOrdering(currentQuestion, typeWrapper);
                        break;
                    case "multiple_choice":
                    default: // Default to multiple choice
                        renderMultipleChoice(currentQuestion, typeWrapper);
                        break;
                }
            } catch (renderError) {
                 console.error("Error rendering question:", renderError);
                 typeWrapper.innerHTML = `<p style="color: red;">Error displaying this question.</p>`;
            }

            questionWrapper.appendChild(typeWrapper);
            quizContainerElement.appendChild(questionWrapper); // Add question wrapper to main quiz container

             // --- Render Buttons ---
             const submitBtn = document.createElement('button');
             submitBtn.className = 'btn submit-btn';
             submitBtn.id = 'submit-btn';
             submitBtn.textContent = 'Submit Answer';
             submitBtn.onclick = checkAnswer;
              // Disable initially for MC and Ordering (needs selection), enable for Matching (needs all pairs)
              submitBtn.disabled = currentQuestion.type !== 'matching';
              if (currentQuestion.type === 'matching' && currentQuestion.prompts && currentQuestion.prompts.length > 0) {
                 submitBtn.disabled = true; // Start matching disabled until all paired
             }


             const nextBtn = document.createElement('button');
             nextBtn.className = 'btn next-btn hidden'; // Always start hidden
             nextBtn.id = 'next-btn';
             nextBtn.textContent = quizState.currentQuestionIndex === quizState.totalQuestions - 1 ? 'See Results' : 'Next Question';
             nextBtn.onclick = nextQuestion;

             quizButtonsContainerElement.appendChild(submitBtn);
             quizButtonsContainerElement.appendChild(nextBtn);
        }

        // --- Rendering Functions for Question Types (Remain Largely the Same) ---

        function renderMultipleChoice(question, container) {
             if (!question.options || !Array.isArray(question.options)) {
                container.textContent = 'Error: Options not available for this question.'; return;
             }
             const optionsDiv = document.createElement('div');
             optionsDiv.className = 'options-container'; optionsDiv.id = 'options-list';

             question.options.forEach((option, index) => {
                 const optionId = `option-${index}`;
                 const optionLabel = document.createElement('label');
                 optionLabel.className = 'option-label'; optionLabel.htmlFor = optionId;
                 const optionInput = document.createElement('input');
                 optionInput.type = 'radio'; optionInput.name = 'question-option'; optionInput.value = index; optionInput.id = optionId; optionInput.className = 'option-input';
                 optionInput.addEventListener('change', () => { document.getElementById('submit-btn').disabled = false; }); // Enable submit on change
                 const optionText = document.createElement('span');
                 optionText.className = 'option-text'; optionText.textContent = option;
                 optionLabel.appendChild(optionInput); optionLabel.appendChild(optionText);
                 optionsDiv.appendChild(optionLabel);
             });
             container.appendChild(optionsDiv);
         }

        function renderMatching(question, container) {
             if (!question.prompts || !question.matches || !Array.isArray(question.prompts) || !Array.isArray(question.matches) || question.prompts.length !== question.matches.length) {
                 container.textContent = 'Error: Invalid matching question data. Ensure prompts and matches arrays have the same length.'; return;
             }

             quizState.matchingState.userPairs = {}; // Reset for this question
             const instructions = document.createElement('p');
             instructions.className = 'matching-instructions'; instructions.textContent = 'Click an item on the left, then click its matching item on the right.';
             container.appendChild(instructions);

             const matchingContainer = document.createElement('div'); matchingContainer.className = 'matching-container';
             const promptsColumn = document.createElement('div'); promptsColumn.className = 'matching-column'; promptsColumn.id = 'prompts-column';
             const promptsHeader = document.createElement('h4'); promptsHeader.textContent = "Items"; promptsColumn.appendChild(promptsHeader);
             const matchesColumn = document.createElement('div'); matchesColumn.className = 'matching-column'; matchesColumn.id = 'matches-column';
             const matchesHeader = document.createElement('h4'); matchesHeader.textContent = "Matches"; matchesColumn.appendChild(matchesHeader);

             const shuffledMatches = question.matches.map((text, idx) => ({ text, originalIndex: idx })).sort(() => Math.random() - 0.5);

             question.prompts.forEach((promptText, index) => {
                 const promptItem = document.createElement('div');
                 promptItem.className = 'matching-item prompt-item'; promptItem.textContent = promptText; promptItem.dataset.index = index;
                 promptItem.addEventListener('click', handleMatchingClick);
                 promptsColumn.appendChild(promptItem);
             });
             shuffledMatches.forEach((matchObj) => {
                 const matchItem = document.createElement('div');
                 matchItem.className = 'matching-item match-item'; matchItem.textContent = matchObj.text; matchItem.dataset.index = matchObj.originalIndex;
                 matchItem.addEventListener('click', handleMatchingClick);
                 matchesColumn.appendChild(matchItem);
             });

             matchingContainer.appendChild(promptsColumn); matchingContainer.appendChild(matchesColumn);
             container.appendChild(matchingContainer);
         }

        function renderOrdering(question, container) {
             if (!question.items || !Array.isArray(question.items) || question.items.length === 0) {
                 container.textContent = 'Error: Invalid ordering question data.'; return;
             }
             const numItems = question.items.length;
             const instructions = document.createElement('p');
             instructions.className = 'ordering-instructions'; instructions.textContent = `Select the correct order number (1-${numItems}) for each item.`;
             container.appendChild(instructions);

             const orderingContainer = document.createElement('div'); orderingContainer.className = 'ordering-container'; orderingContainer.id = 'ordering-list';

             question.items.forEach((itemText, index) => {
                 const itemDiv = document.createElement('div'); itemDiv.className = 'ordering-item'; itemDiv.dataset.originalIndex = index;
                 const select = document.createElement('select'); select.className = 'ordering-select'; select.dataset.itemIndex = index;
                 const defaultOption = document.createElement('option'); defaultOption.value = ""; defaultOption.textContent = "-"; defaultOption.selected = true; defaultOption.disabled = true; select.appendChild(defaultOption);
                 for (let i = 1; i <= numItems; i++) {
                     const option = document.createElement('option'); option.value = i; option.textContent = i; select.appendChild(option);
                 }
                 // Add listener to check if all selects have values
                  select.addEventListener('change', () => {
                      const allSelected = Array.from(document.querySelectorAll('.ordering-select')).every(s => s.value !== "");
                      document.getElementById('submit-btn').disabled = !allSelected;
                  });

                 const textSpan = document.createElement('span'); textSpan.className = 'ordering-text'; textSpan.textContent = itemText;
                 itemDiv.appendChild(select); itemDiv.appendChild(textSpan);
                 orderingContainer.appendChild(itemDiv);
             });
             container.appendChild(orderingContainer);
              // Start with submit disabled for ordering
             document.getElementById('submit-btn').disabled = true;
         }


        // --- Interaction Handlers ---

        function handleMatchingClick(event) {
             const clickedItem = event.target;
             if (clickedItem.classList.contains('matched') || !clickedItem.classList.contains('matching-item')) return;

             const isPrompt = clickedItem.classList.contains('prompt-item');
             let currentSelection = quizState.matchingState.selectedPromptElement;

             if (isPrompt) {
                 if (currentSelection) currentSelection.classList.remove('selected');
                 if (currentSelection !== clickedItem) {
                     clickedItem.classList.add('selected'); quizState.matchingState.selectedPromptElement = clickedItem;
                 } else { quizState.matchingState.selectedPromptElement = null; }
             } else { // Clicked a match item
                 if (currentSelection) { // If a prompt is selected
                     const promptIndex = currentSelection.dataset.index;
                     const matchIndex = clickedItem.dataset.index;
                     quizState.matchingState.userPairs[promptIndex] = parseInt(matchIndex, 10);

                     currentSelection.classList.remove('selected'); currentSelection.classList.add('matched'); clickedItem.classList.add('matched');
                     currentSelection.style.cursor = 'default'; clickedItem.style.cursor = 'default';
                     quizState.matchingState.selectedPromptElement = null;

                     const totalPrompts = document.querySelectorAll('.prompt-item').length;
                     const matchedPrompts = document.querySelectorAll('.prompt-item.matched').length;
                     if (matchedPrompts === totalPrompts) { document.getElementById('submit-btn').disabled = false; }
                 }
             }
         }


        // --- Answer Checking Functions ---

        function checkAnswer() {
             if (!feedbackContainerElement || !quizButtonsContainerElement) return;

             const currentQuestion = quizState.questions[quizState.currentQuestionIndex];
             let result = { isCorrect: false, feedback: '', userResponse: null, scoreIncrement: 0 };

             try {
                 switch (currentQuestion.type) {
                     case "matching": result = checkMatching(currentQuestion); break;
                     case "ordering": result = checkOrdering(currentQuestion); break;
                     case "multiple_choice": default: result = checkMultipleChoice(currentQuestion); break;
                 }
             } catch (error) {
                 console.error("Error during answer checking:", error);
                 result = { isCorrect: false, feedback: '<div class="incorrect-feedback">An error occurred checking the answer.</div>', userResponse: null, scoreIncrement: 0 };
             }

             quizState.selectedAnswers[quizState.currentQuestionIndex] = result.userResponse;
             if (result.isCorrect) { quizState.correctAnswers += result.scoreIncrement; } // Only add score if fully correct

             feedbackContainerElement.innerHTML = result.feedback;
             feedbackContainerElement.classList.remove('hidden');

             disableInputs();
             const submitBtn = quizButtonsContainerElement.querySelector('#submit-btn');
             const nextBtn = quizButtonsContainerElement.querySelector('#next-btn');
             if (submitBtn) submitBtn.classList.add('hidden');
             if (nextBtn) nextBtn.classList.remove('hidden');
         }

         // checkMultipleChoice, checkMatching, checkOrdering remain the same logic as before
         // (Ensure they return the object { isCorrect, feedback, userResponse, scoreIncrement })

         function checkMultipleChoice(question) {
            const selectedOptionInput = document.querySelector('input[name="question-option"]:checked');
            if (!selectedOptionInput) {
                return { isCorrect: false, feedback: '<div class="incorrect-feedback">Please select an answer.</div>', userResponse: null, scoreIncrement: 0 };
            }
            const selectedIndex = parseInt(selectedOptionInput.value, 10);
            const correctOptionText = question.answer;
            const selectedOptionText = question.options[selectedIndex];
            const isCorrect = selectedOptionText === correctOptionText;

            document.querySelectorAll('.option-label').forEach((label, index) => {
                 const input = label.querySelector('input');
                 if (question.options[index] === correctOptionText) label.classList.add('correct-option');
                 if (input && parseInt(input.value, 10) === selectedIndex && !isCorrect) label.classList.add('incorrect-option');
             });

            const feedback = isCorrect ? '<div class="correct-feedback">Correct! ✓</div>' : `<div class="incorrect-feedback">Incorrect. <span>Correct: ${correctOptionText}</span></div>`;
            return { isCorrect, feedback, userResponse: selectedIndex, scoreIncrement: isCorrect ? 1 : 0 };
         }

         function checkMatching(question) {
             const userPairs = quizState.matchingState.userPairs;
             const correctPairs = question.answer;
             const totalPairs = Object.keys(correctPairs).length;
             let correctCount = 0;
             if (totalPairs === 0) { // Handle case of empty matching question
                  return { isCorrect: true, feedback: '<div class="correct-feedback">N/A</div>', userResponse: userPairs, scoreIncrement: 0 };
             }

             for (const promptIndex in correctPairs) {
                 if (userPairs.hasOwnProperty(promptIndex) && userPairs[promptIndex] === correctPairs[promptIndex]) { correctCount++; }
             }
             const isFullyCorrect = correctCount === totalPairs;
             let feedback = '';
             if (isFullyCorrect) feedback = `<div class="correct-feedback">Correct! All pairs matched. ✓ (${correctCount}/${totalPairs})</div>`;
             else if (correctCount > 0) feedback = `<div class="partial-feedback">Partially Correct. Matched ${correctCount}/${totalPairs}.</div>`;
             else feedback = `<div class="incorrect-feedback">Incorrect. Matched 0/${totalPairs}.</div>`;

             return { isCorrect: isFullyCorrect, feedback, userResponse: userPairs, scoreIncrement: isFullyCorrect ? 1 : 0 };
         }

         function checkOrdering(question) {
            const numItems = question.items.length;
            if (numItems === 0) { // Handle empty case
                return { isCorrect: true, feedback: '<div class="correct-feedback">N/A</div>', userResponse: [], scoreIncrement: 0 };
            }

            const userOrderMap = {}; // { originalIndex: selectedOrderNumber }
            const selectedNumbers = new Set();
            let allSelected = true;
            let hasDuplicate = false;

            const selects = document.querySelectorAll('#ordering-list .ordering-select'); // Target selects within the container

            selects.forEach(select => {
                const itemIndex = parseInt(select.dataset.itemIndex, 10);
                const selectedValue = select.value;

                if (selectedValue === "") {
                    allSelected = false;
                } else {
                    const orderNum = parseInt(selectedValue, 10);
                    userOrderMap[itemIndex] = orderNum;
                    if (selectedNumbers.has(orderNum)) {
                        hasDuplicate = true;
                    }
                    selectedNumbers.add(orderNum);
                }
            });

            // 1. Check if all items have a selection
            if (!allSelected) {
                return { isCorrect: false, feedback: '<div class="incorrect-feedback">Please select an order number for every item.</div>', userResponse: null, scoreIncrement: 0 };
            }

            // 2. Check if all numbers from 1 to numItems were used exactly once
            if (hasDuplicate || selectedNumbers.size !== numItems) {
                 return { isCorrect: false, feedback: `<div class="incorrect-feedback">Please use each order number (1-${numItems}) exactly once.</div>`, userResponse: null, scoreIncrement: 0 };
            }

            // If validation passes, construct the user's ordered array
            const userOrderedItems = new Array(numItems).fill(null); // Initialize with nulls
            let constructionOk = true;
            for (const originalIndex in userOrderMap) {
                 if (userOrderMap.hasOwnProperty(originalIndex)) {
                     const itemText = question.items[originalIndex];
                     const userPosition = userOrderMap[originalIndex] - 1; // 0-based index
                     if (userPosition >= 0 && userPosition < numItems) {
                         if (userOrderedItems[userPosition] === null) { // Check if position is already filled (shouldn't happen if no duplicates)
                             userOrderedItems[userPosition] = itemText;
                         } else {
                             constructionOk = false; break; // Error in logic if this happens
                         }
                     } else {
                         constructionOk = false; break; // Invalid position calculated
                     }
                 }
            }

             if (!constructionOk || userOrderedItems.some(item => item === null)) {
                 console.error("Error constructing user's ordered list.", userOrderMap, userOrderedItems);
                 return { isCorrect: false, feedback: '<div class="incorrect-feedback">Error processing your order.</div>', userResponse: null, scoreIncrement: 0 };
             }


            // Compare with the correct answer
            const correctOrder = question.answer;
            const isCorrect = JSON.stringify(userOrderedItems) === JSON.stringify(correctOrder);

            let feedback = '';
            if (isCorrect) {
                feedback = `<div class="correct-feedback">Correct! The order is perfect. ✓</div>`;
            } else {
                feedback = `<div class="incorrect-feedback">Incorrect. <span>Correct order: ${correctOrder.join(' → ')}</span></div>`;
            }

             // Add visual feedback to selects
             selects.forEach(select => {
                 const originalIndex = parseInt(select.dataset.itemIndex, 10);
                 const userNum = userOrderMap[originalIndex];
                 const correctNum = correctOrder.indexOf(question.items[originalIndex]) + 1;
                 select.style.borderColor = (userNum === correctNum) ? '#16a34a' : '#ef4444';
                 select.style.borderWidth = '2px';
             });


            return {
                isCorrect: isCorrect,
                feedback: feedback,
                userResponse: userOrderedItems, // Store the user's ordered array
                scoreIncrement: isCorrect ? 1 : 0
            };
        }


        // Helper to disable inputs after submission
        function disableInputs() {
             document.querySelectorAll('input[name="question-option"], .ordering-select').forEach(input => input.disabled = true);
             document.querySelectorAll('.option-label').forEach(label => label.style.cursor = 'default');
             document.querySelectorAll('.matching-item').forEach(item => { item.style.pointerEvents = 'none'; item.style.cursor = 'default'; });
         }


        // --- Navigation and Results ---

        function nextQuestion() {
            quizState.currentQuestionIndex++;
            if (quizState.currentQuestionIndex < quizState.totalQuestions) {
                displayQuestion();
            } else {
                quizState.endTime = new Date();
                displayResults();
            }
        }

        // Display results within the #quiz-container
        function displayResults() {
             if (!quizContainerElement || !feedbackContainerElement || !quizButtonsContainerElement) return;

             quizContainerElement.innerHTML = ''; // Clear question area
             feedbackContainerElement.classList.add('hidden'); // Hide feedback area
             quizButtonsContainerElement.innerHTML = ''; // Clear standard buttons

             const timeTaken = quizState.endTime && quizState.startTime ? (quizState.endTime - quizState.startTime) / 1000 : 0;
             const minutes = Math.floor(timeTaken / 60);
             const seconds = Math.floor(timeTaken % 60);
             const timeString = timeTaken > 0 ? `${minutes}m ${seconds}s` : 'N/A';
             const scorePercentage = quizState.totalQuestions > 0 ? (quizState.correctAnswers / quizState.totalQuestions) * 100 : 0;
             let performanceMessage = ''; // Determine message based on score... (same as before)
              if (quizState.totalQuestions === 0) performanceMessage = 'No questions were answered.';
              else if (scorePercentage >= 90) performanceMessage = 'Excellent job! 🎉';
              else if (scorePercentage >= 70) performanceMessage = 'Good work! 👍';
              else if (scorePercentage >= 50) performanceMessage = 'Not bad. Keep practicing! 💪';
              else performanceMessage = 'You might need more study time. 📚';


             const resultsDiv = document.createElement('div');
             resultsDiv.className = 'results-container';
             resultsDiv.innerHTML = `
                <h2 class="results-header">${performanceMessage}</h2>
                <div class="results-score"> <div class="score-circle"> <span class="score-number">${scorePercentage.toFixed(0)}</span> <span class="score-percent-sign">%</span> </div> </div>
                <div class="results-details">
                    <p><strong>Subject:</strong> ${quizState.subject || 'N/A'}</p> <p><strong>Unit:</strong> ${quizState.unit || 'N/A'}</p> <p><strong>Lesson:</strong> ${quizState.lesson || 'N/A'}</p>
                    <p><strong>Correct Answers:</strong> ${quizState.correctAnswers} out of ${quizState.totalQuestions}</p> <p><strong>Time Taken:</strong> ${timeString}</p>
                </div>`;
             quizContainerElement.appendChild(resultsDiv);

             // Add Results Buttons to the button container
             const actionsDiv = document.createElement('div');
             actionsDiv.className = 'results-actions'; // Use specific class if needed
             if (quizState.totalQuestions > 0) {
                 const reviewBtn = document.createElement('button');
                 reviewBtn.id = 'review-btn'; reviewBtn.className = 'btn review-btn'; reviewBtn.textContent = 'Review Answers';
                 reviewBtn.addEventListener('click', reviewAnswers);
                 actionsDiv.appendChild(reviewBtn);
             }
             const backBtn = document.createElement('button');
             backBtn.className = 'btn back-to-topics-btn'; backBtn.textContent = 'Back to Topics';
             backBtn.onclick = showTopicList; // Use the view switching function
             actionsDiv.appendChild(backBtn);
             quizButtonsContainerElement.appendChild(actionsDiv);
         }

        // --- Answer Review Functions (Render into #quiz-container) ---

        function reviewAnswers() {
             if (!quizContainerElement || !feedbackContainerElement || !quizButtonsContainerElement) return;

             quizContainerElement.innerHTML = ''; // Clear results
             feedbackContainerElement.classList.add('hidden'); // Hide feedback
             quizButtonsContainerElement.innerHTML = ''; // Clear results buttons

             if (quizTitleElement) quizTitleElement.textContent = `Review: ${quizState.lesson}`; // Update title

             const reviewDiv = document.createElement('div');
             reviewDiv.className = 'review-container';

             // Render each question review
             quizState.questions.forEach((question, index) => {
                 const questionReview = document.createElement('div');
                 const userAnswer = quizState.selectedAnswers[index];
                 let { correctnessClass, statusText } = calculateReviewStatus(question, userAnswer); // Use helper

                 questionReview.className = `question-review ${correctnessClass}`;
                 questionReview.innerHTML = `
                    <div class="review-question-header">
                        <span class="review-question-number">Question ${index + 1} (${question.type.replace('_', ' ')})</span>
                        <span class="review-status">${statusText}</span>
                    </div>
                    <p class="review-question-text">${question.question || 'Missing question text'}</p>
                    <div id="review-answer-content-${index}"></div>`;
                 reviewDiv.appendChild(questionReview);

                 const reviewContentContainer = reviewDiv.querySelector(`#review-answer-content-${index}`);
                 if (reviewContentContainer) {
                     try {
                          switch (question.type) {
                              case "matching": reviewMatchingReview(question, userAnswer, reviewContentContainer); break; // Renamed review renderers
                              case "ordering": reviewOrderingReview(question, userAnswer, reviewContentContainer); break;
                              case "multiple_choice": default: reviewMultipleChoiceReview(question, userAnswer, reviewContentContainer); break;
                          }
                     } catch (reviewError) {
                         console.error("Error rendering review for question", index, reviewError);
                         reviewContentContainer.innerHTML = `<p style="color: red;">Error displaying review.</p>`;
                     }
                 }
             });
             quizContainerElement.appendChild(reviewDiv); // Add all reviews to quiz container

             // Add Review Buttons
             const actionsDiv = document.createElement('div');
             actionsDiv.className = 'review-actions'; // Specific class for review buttons layout
             const backToResultsBtn = document.createElement('button');
             backToResultsBtn.className = 'btn back-btn'; backToResultsBtn.textContent = '← Back to Results';
             backToResultsBtn.addEventListener('click', displayResults);
             actionsDiv.appendChild(backToResultsBtn);
              const backToTopicsBtn = document.createElement('button');
             backToTopicsBtn.className = 'btn back-to-topics-btn'; backToTopicsBtn.textContent = 'Back to Topics';
             backToTopicsBtn.onclick = showTopicList;
             actionsDiv.appendChild(backToTopicsBtn);

             quizButtonsContainerElement.appendChild(actionsDiv);
         }

         // Helper to determine review status class/text
         function calculateReviewStatus(question, userAnswer) {
             let correctnessClass = 'incorrect'; let statusText = '✗ Incorrect'; let reviewCorrectness = false;
             try {
                 switch (question.type) {
                     case "matching":
                         const correctPairs = question.answer || {}; const totalPairs = Object.keys(correctPairs).length; let correctCount = 0;
                         if (totalPairs > 0 && userAnswer && typeof userAnswer === 'object') {
                             for (const promptIndex in correctPairs) {
                                 if (userAnswer.hasOwnProperty(promptIndex) && userAnswer[promptIndex] === correctPairs[promptIndex]) correctCount++;
                             }
                         }
                         reviewCorrectness = totalPairs > 0 && (correctCount === totalPairs);
                         if (reviewCorrectness) { correctnessClass = 'correct'; statusText = '✓ Correct'; }
                         else if (correctCount > 0) { correctnessClass = 'partial'; statusText = `~ Partial (${correctCount}/${totalPairs})`; }
                         break; // Keep default incorrect if 0 correct
                     case "ordering":
                         if (userAnswer && Array.isArray(userAnswer) && question.answer && Array.isArray(question.answer)) {
                             reviewCorrectness = JSON.stringify(userAnswer) === JSON.stringify(question.answer);
                         }
                         correctnessClass = reviewCorrectness ? 'correct' : 'incorrect'; statusText = reviewCorrectness ? '✓ Correct' : '✗ Incorrect';
                         break;
                     case "multiple_choice": default:
                         if (userAnswer !== null && question.options && question.answer) {
                             reviewCorrectness = (question.options[userAnswer] === question.answer);
                         }
                         correctnessClass = reviewCorrectness ? 'correct' : 'incorrect'; statusText = reviewCorrectness ? '✓ Correct' : '✗ Incorrect';
                         break;
                 }
             } catch(e) { console.error("Error in calculateReviewStatus", e); /* Keep default incorrect */ }
             return { correctnessClass, statusText };
         }


         // Renamed Review Rendering functions (logic remains the same)
         function reviewMultipleChoiceReview(question, userAnswerIndex, container) { /* Use logic from previous reviewMultipleChoice */
              const div = document.createElement('div'); div.className = 'review-mc-answer';
              const userSelectedText = (userAnswerIndex !== null && question.options && question.options[userAnswerIndex] !== undefined) ? question.options[userAnswerIndex] : 'No answer selected';
              const isCorrect = (userAnswerIndex !== null) && (userSelectedText === question.answer);
              div.innerHTML = `<p><strong>Your answer:</strong> <span class="user-answer-text ${isCorrect ? 'correct' : (userAnswerIndex !== null ? 'incorrect' : '')}">${userSelectedText}</span></p>${!isCorrect ? `<p><strong>Correct answer:</strong> <span class="correct-answer-text">${question.answer || 'N/A'}</span></p>` : ''}`;
              container.appendChild(div);
          }
         function reviewMatchingReview(question, userPairs, container) { /* Use logic from previous reviewMatching */
              const div = document.createElement('div'); div.className = 'review-matching-answer'; div.innerHTML = `<p><strong>Matching Review:</strong></p>`;
              const reviewGrid = document.createElement('div'); reviewGrid.className = 'review-matching-grid';
              const promptsCol = document.createElement('div'); promptsCol.className = 'review-matching-column';
              const matchesCol = document.createElement('div'); matchesCol.className = 'review-matching-column';
              const correctPairs = question.answer || {};

              (question.prompts || []).forEach((promptText, promptIndex) => {
                  const userMatchIndex = userPairs ? userPairs[promptIndex] : null;
                  const correctMatchIndex = correctPairs[promptIndex]; // Can be undefined if data bad
                  const isPairCorrect = userMatchIndex !== null && userMatchIndex === correctMatchIndex;

                  const promptDiv = document.createElement('div'); promptDiv.textContent = promptText;
                  const matchDiv = document.createElement('div');
                  const userMatchText = (userMatchIndex !== null && question.matches && question.matches[userMatchIndex]) ? question.matches[userMatchIndex] : '(No match)';
                  const correctMatchText = (correctMatchIndex !== undefined && question.matches && question.matches[correctMatchIndex]) ? question.matches[correctMatchIndex] : '(N/A)';

                  if (isPairCorrect) {
                      promptDiv.classList.add('review-matched-pair-correct'); matchDiv.textContent = correctMatchText; matchDiv.classList.add('review-matched-pair-correct');
                  } else {
                      promptDiv.classList.add('review-matched-pair-incorrect'); matchDiv.innerHTML = `<span style="text-decoration: line-through; color: #dc2626;">${userMatchText}</span> <span style="color: #059669;">(${correctMatchText})</span>`; matchDiv.classList.add('review-matched-pair-incorrect');
                  }
                  promptsCol.appendChild(promptDiv); matchesCol.appendChild(matchDiv);
              });
              reviewGrid.appendChild(promptsCol); reviewGrid.appendChild(matchesCol); div.appendChild(reviewGrid); container.appendChild(div);
          }
         function reviewOrderingReview(question, userOrderedItems, container) { /* Use logic from previous reviewOrdering */
              const div = document.createElement('div'); div.className = 'review-ordering-answer';
              const correctOrder = question.answer || [];
              const isCorrect = userOrderedItems && (JSON.stringify(userOrderedItems) === JSON.stringify(correctOrder));
              div.innerHTML = `<p><strong>Ordering Review:</strong></p>`;
              const listDiv = document.createElement('div'); listDiv.className = 'review-ordering-list';

              correctOrder.forEach((correctItemText, correctIndex) => {
                   const itemDiv = document.createElement('div'); itemDiv.className = 'review-ordering-list-item';
                   const userIndex = userOrderedItems ? userOrderedItems.indexOf(correctItemText) : -1;
                   const userNumber = (userIndex !== -1) ? userIndex + 1 : null;
                   const correctNumber = correctIndex + 1;
                   let userNumSpan = '';
                   if (userNumber === correctNumber) userNumSpan = `<span class="review-order-number review-order-correct">${userNumber}.</span>`;
                   else if (userNumber !== null) userNumSpan = `<span class="review-order-number review-order-incorrect">${userNumber}.</span> <span class="review-order-number review-order-correct">(${correctNumber}.)</span>`;
                   else userNumSpan = `<span class="review-order-number review-order-incorrect">(N/P)</span> <span class="review-order-number review-order-correct">(${correctNumber}.)</span>`; // N/P = Not Placed
                   itemDiv.innerHTML = `${userNumSpan} ${correctItemText}`; listDiv.appendChild(itemDiv);
              });
              div.appendChild(listDiv);
              if (!isCorrect && userOrderedItems) div.innerHTML += `<p style="margin-top: 10px;"><strong>Your Order:</strong> ${userOrderedItems.join(' → ')}</p>`;
              container.appendChild(div);
          }


        // --- Error Display (within #quiz-container) ---
        function showError(subject, unit, lesson, message = '') {
             if (!quizContainerElement || !feedbackContainerElement || !quizButtonsContainerElement || !quizTitleElement) return;

            showQuizView(); // Ensure quiz view is visible
            quizTitleElement.textContent = 'Error'; // Set title

             quizContainerElement.innerHTML = ''; // Clear question area
             feedbackContainerElement.classList.add('hidden'); // Hide feedback area
             quizButtonsContainerElement.innerHTML = ''; // Clear standard buttons

            const defaultMessage = `Sorry, no questions are available yet for ${lesson} in ${unit}.`;
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-display'; // Use new class for styling
            errorDiv.innerHTML = `<div class="error-message">${message || defaultMessage}</div>`;

             // Add Back Button
             const backBtn = document.createElement('button');
             backBtn.className = 'btn back-to-topics-btn';
             backBtn.textContent = 'Back to Topics';
             backBtn.onclick = showTopicList;
             errorDiv.appendChild(backBtn);

            quizContainerElement.appendChild(errorDiv); // Add error display to quiz container
        }

        // --- Get Questions Data ---
        function getQuestions(subject, unitTitle, lessonTitle) {
             const activeSemesterBtn = document.querySelector('.semester-btn.active');
             if (!activeSemesterBtn) { console.error("Cannot determine active semester."); return []; }
             const activeSemester = activeSemesterBtn.dataset.semester;
             if (!subject || !unitTitle || !lessonTitle || !activeSemester) { console.error("Missing params for getQuestions."); return []; }

             try {
                 const subjectData = topicsData[subject];
                 const semesterData = subjectData ? subjectData[activeSemester] : null;
                 const units = semesterData ? semesterData.units : null;
                 if (!units) { console.warn(`Data structure missing: ${subject} -> ${activeSemester}`); return []; }

                 const unit = units.find(u => u && u.title === unitTitle);
                 const lessons = unit ? unit.lessons : null;
                 if (!lessons) { console.warn(`Unit "${unitTitle}" or lessons not found.`); return []; }

                 const lesson = lessons.find(l => l && l.title === lessonTitle);
                 if (!lesson) { console.warn(`Lesson "${lessonTitle}" not found.`); return []; }

                 if (lesson.questions && Array.isArray(lesson.questions)) {
                      // Add default type ONLY if 'type' is completely missing
                      return lesson.questions.map(q => ({ type: q.type || 'multiple_choice', ...q }));
                 } else { return []; }
             } catch (error) {
                 console.error("Error finding questions:", error); return [];
             }
         }

        // --- END OF questions.js ---
    </script>

</body>
</html>
